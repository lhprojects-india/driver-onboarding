rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to get user email from token (handles both regular and custom tokens)
    // For Google sign-in, email is in request.auth.token.email
    // For custom tokens, email might be in request.auth.token.claims.email
    function getUserEmail() {
      // For Google sign-in, email is directly in request.auth.token.email
      // For custom tokens, it might be in request.auth.token.claims.email
      return request.auth != null && request.auth.token != null
        ? (request.auth.token.email != null 
           ? request.auth.token.email 
           : (request.auth.token.claims != null && request.auth.token.claims.email != null
              ? request.auth.token.claims.email
              : null))
        : null;
    }
    
    // Helper function to check if user is admin
    // NOTE: Firestore rules cannot dynamically check the authorized_emails collection
    // due to path construction limitations. The client-side code (AdminAuthContext) 
    // checks Firestore first, which is the source of truth.
    // This hardcoded list is used for Firestore security rules evaluation only.
    // IMPORTANT: Keep this list in sync with authorized_emails collection
    // Note: Email comparison is case-sensitive - emails in Firestore should be lowercase
    // Google sign-in emails are always lowercase
    function isAdmin() {
      let userEmail = getUserEmail();
      return request.auth != null && 
             userEmail != null &&
             (userEmail == 'hari@laundryheap.com' ||
              userEmail == 'admin@laundryheap.com' ||
              userEmail == 'bharath@laundryheap.com' ||
              userEmail == 'sudhanva@laundryheap.com' ||
              userEmail == 'mohammed.raquib@laundryheap.com' ||
              userEmail == 'ramanujan@laundryheap.com');
    }
    
    // Helper function to check if user owns the document or is admin
    // Supports both regular tokens and custom tokens with email in claims
    // Note: Email comparison is case-sensitive - emails in Firestore should be lowercase
    function isOwnerOrAdmin(email) {
      let userEmail = getUserEmail();
      return request.auth != null && 
        userEmail != null &&
        // Check if user owns the document (exact match) OR is admin
        (userEmail == email || isAdmin());
    }
    
    // Helper function to allow writes for authenticated users or for testing (mock mode)
    // WARNING: This allows unauthenticated writes for testing - restrict in production!
    function canWriteForTesting(email) {
      return request.auth != null || true; // Allow unauthenticated writes for mock mode testing
    }
    
    // Authorized emails collection - users can check their own email, admins can read all
    // NOTE: Users can read their own document to check authorization (used by AdminAuthContext)
    // Admins can read all documents. This allows the client-side code to check Firestore first.
    match /authorized_emails/{email} {
      // Allow users to check if their own email is authorized (for login verification)
      // This is used by AdminAuthContext.checkAdminAuthorization() to check Firestore first
      allow read: if request.auth != null && 
                     getUserEmail() != null && 
                     (getUserEmail().lower() == email.lower() || isAdmin());
      allow write: if false; // Only Admin SDK can write
    }
    
    // Fountain applicants collection - users can read their own data, admins can read all
    match /fountain_applicants/{email} {
      allow read: if isOwnerOrAdmin(email);
      allow write: if false; // Only cloud functions can write
    }
    
    // Drivers collection - users can access their own data, admins can access all
    match /drivers/{email} {
      allow read: if isOwnerOrAdmin(email);
      allow write: if canWriteForTesting(email);
    }

    // Availability collection - users can access their own data, admins can access all
    match /availability/{email} {
      allow read: if isOwnerOrAdmin(email);
      allow write: if canWriteForTesting(email);
    }

    // Verification collection - users can access their own data, admins can access all
    match /verification/{email} {
      allow read: if isOwnerOrAdmin(email);
      allow write: if canWriteForTesting(email);
    }
    
    // Onboarding collection - track progress
    match /onboarding/{email} {
      allow read: if isOwnerOrAdmin(email);
      allow write: if canWriteForTesting(email);
    }
    
    // Reports collection - completed onboarding reports
    // Admins can read all reports, authenticated users can read any
    match /reports/{reportId} {
      allow read: if isAdmin() || request.auth != null; // Admins can read all, authenticated users can read any
      allow write: if true; // Allow writes for mock mode testing (restrict in production)
    }
    
    // Fee structures collection - public read, admin write only
    match /fee_structures/{city} {
      allow read: if true; // Allow all reads (public pricing information)
      allow write: if isAdmin(); // Only admins can write
    }
    
    // Facilities collection - public read, admin write only
    match /facilities/{facilityCode} {
      allow read: if true; // Allow all reads (drivers need to see facilities for their city)
      allow write: if isAdmin(); // Only admins can write
    }
    
    // Admins collection - any authenticated user can read to check if they are an admin
    // This is needed for the authorization flow to work properly
    match /admins/{email} {
      // Allow any authenticated user to read any admin document
      // This is needed so they can check if they are an admin and what their role is
      allow read: if request.auth != null;
      // Allow any authenticated user to write (the client-side code enforces role checks)
      // In a more secure setup, you would check if the user is already a super_admin
      // but Firestore rules can't easily check the collection dynamically
      allow write: if request.auth != null;
    }
  }
}
